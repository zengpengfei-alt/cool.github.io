<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cool</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-07-30T06:34:58.355Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>cool</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HashMap</title>
    <link href="http://example.com/2021/05/18/HashMap/"/>
    <id>http://example.com/2021/05/18/HashMap/</id>
    <published>2021-05-18T07:48:41.000Z</published>
    <updated>2021-07-30T06:34:58.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>hashMap不管是在实际使用中还是面试中都是高频出现的</p><p>在jdk1.7版本及之前，hashMap采用数组加链表的方法，首先来说下为什么采用数组加链表的方式，put数据时hashmap会通过hash算法得到一个类似存储地址，也差不多就是数组的下标，但是如果多个数据通过hash算法之后得到了同一个地址就会产生冲突，我们称之为hash冲突，这个时候我们会采用头插法避免hash冲突，但是这样的话，查询的时候如果没有链表的话，只要找到下标就可以根据映射找到数据，如果有链表还要遍历才能找到，效率变低。</p><hr><p>[TOC]</p><h2 id="hashMap结构图"><a href="#hashMap结构图" class="headerlink" title="hashMap结构图"></a>hashMap结构图</h2><h3 id="1-7-hashmap"><a href="#1-7-hashmap" class="headerlink" title="1.7 hashmap"></a>1.7 hashmap</h3><p><img src="/2021/05/18/HashMap/26075772-5c3393ae04229968.png" alt="hashMap结构图"></p><blockquote><p>简单说下扩容机制：</p></blockquote><blockquote><p>1.7及之前 hashmap的初始化空间为16，负载因子是0.75（为什么是0.75呢？总结：负载因子是0.75的时候，空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率）<br>阈值=初始空间*0.75=12<br>当hashmap的size大于等于阈值，并且产生hash冲突的时候，hashmap才会扩容扩容空间固定为之前的两倍<br>（为了保证新老数组索引一致，减少位置调换）</p></blockquote><h3 id="1-8之后hashmap进行了优化，首先就是引入了红黑树"><a href="#1-8之后hashmap进行了优化，首先就是引入了红黑树" class="headerlink" title="1.8之后hashmap进行了优化，首先就是引入了红黑树"></a>1.8之后hashmap进行了优化，首先就是引入了红黑树</h3><p><img src="/2021/05/18/HashMap/26075772-7aca994cc5278eb9.png" alt="1.8 hashMap结构图"></p><blockquote><p>jdk1.8及之后引入了红黑树，使其查找的更快速，也由1.7之前的头插法改为了尾插法，为什么用尾插法？</p></blockquote><blockquote><p>一：由于resize的赋值方式，扩容之后链表上的元素会反过来,这样的话就会形成链表，进而可能造成死循环。</p></blockquote><p><img src="/2021/05/18/HashMap/26075772-a33260a12b0c088a.png" alt="1.8 hashMap结构图"></p><blockquote><p>同样条件jdk1.8hashmap采用尾插法在扩容之后链表顺序不变，节点不变。</p></blockquote><blockquote><p>二、设计思想，认为最后put进去的值可能就是最近需要取出的；</p></blockquote><h2 id="hashMap源码分析"><a href="#hashMap源码分析" class="headerlink" title="hashMap源码分析"></a>hashMap源码分析</h2><h3 id="1-7源码分析-put方法"><a href="#1-7源码分析-put方法" class="headerlink" title="1.7源码分析-put方法"></a>1.7源码分析-put方法</h3><p><img src="/2021/05/18/HashMap/26075772-858205447441c834.png" alt="1.7源码分析-put方法"></p><h3 id="1-7源码分析-addEntry方法"><a href="#1-7源码分析-addEntry方法" class="headerlink" title="1.7源码分析-addEntry方法"></a>1.7源码分析-addEntry方法</h3><p><img src="/2021/05/18/HashMap/26075772-23c167e3ee98a84e.png" alt="addEntry方法"></p><h3 id="1-7源码分析-resize方法"><a href="#1-7源码分析-resize方法" class="headerlink" title="1.7源码分析-resize方法"></a>1.7源码分析-resize方法</h3><p><img src="/2021/05/18/HashMap/26075772-24827bc6e9995372.png" alt="resize方法"></p><h3 id="1-8源码分析-put方法"><a href="#1-8源码分析-put方法" class="headerlink" title="1.8源码分析-put方法"></a>1.8源码分析-put方法</h3><p><img src="/2021/05/18/HashMap/26075772-858205447441c834.png" alt="1.8源码分析-put方法"></p><h3 id="1-8源码分析-resize方法"><a href="#1-8源码分析-resize方法" class="headerlink" title="1.8源码分析-resize方法"></a>1.8源码分析-resize方法</h3><blockquote><p>—————————————————–开始—————————————————–<br>   final Node&lt;K,V&gt;[] resize() {</p></blockquote><blockquote><pre><code>   Node&lt;K,V&gt;[] oldTab = table;</code></pre></blockquote><blockquote><pre><code>   //之前的空间为null则替换为0</code></pre></blockquote><blockquote><pre><code>   int oldCap = (oldTab == null) ? 0 : oldTab.length;</code></pre></blockquote><blockquote><pre><code>   int oldThr = threshold;</code></pre></blockquote><blockquote><pre><code>   int newCap, newThr = 0;</code></pre></blockquote><blockquote><p>   //之前空间大于0，如果之前空间大于最大容器空间则不扩容；反之，当前空间大于初始化空间则扩容</p></blockquote><blockquote><pre><code>   if (oldCap &gt; 0) &#123;</code></pre></blockquote><blockquote><pre><code>       if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</code></pre></blockquote><blockquote><pre><code>           threshold = Integer.MAX_VALUE;</code></pre></blockquote><blockquote><pre><code>           return oldTab;</code></pre></blockquote><blockquote><pre><code>       &#125;</code></pre></blockquote><blockquote><pre><code>       else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</code></pre></blockquote><blockquote><pre><code>           oldCap &gt;= DEFAULT_INITIAL_CAPACITY)                     </code></pre></blockquote><blockquote><pre><code>           newThr = oldThr &lt;&lt; 1; // double threshold</code></pre></blockquote><blockquote><pre><code>       &#125;</code></pre></blockquote><blockquote><pre><code>       //自定义初始空间则返回自定义空间</code></pre></blockquote><blockquote><pre><code>       else if (oldThr &gt; 0) // initial capacity was placed in threshold</code></pre></blockquote><blockquote><pre><code>       newCap = oldThr;</code></pre></blockquote><blockquote><pre><code>       //否则使用默认分配空间</code></pre></blockquote><blockquote><pre><code>       else &#123;              // zero initial threshold signifies using defaults</code></pre></blockquote><blockquote><pre><code>           newCap = DEFAULT_INITIAL_CAPACITY;</code></pre></blockquote><blockquote><pre><code>           newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</code></pre></blockquote><blockquote><pre><code>       &#125;</code></pre></blockquote><blockquote><p>   //阈值为0，判断空间容量是否超过最大空间，不超过的话则为新的空间容量*负载因子，不然赋值为最大容量</p></blockquote><blockquote><pre><code>   if (newThr == 0) &#123;</code></pre></blockquote><blockquote><pre><code>       float ft = (float)newCap * loadFactor;</code></pre></blockquote><blockquote><pre><code>       newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</code></pre></blockquote><blockquote><pre><code>         (int)ft : Integer.MAX_VALUE);</code></pre></blockquote><blockquote><pre><code>   &#125;</code></pre></blockquote><blockquote><pre><code>   threshold = newThr;</code></pre></blockquote><blockquote><pre><code>   @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</code></pre></blockquote><blockquote><pre><code>   Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</code></pre></blockquote><blockquote><pre><code>   table = newTab;</code></pre></blockquote><blockquote><pre><code>   //扩容</code></pre></blockquote><blockquote><pre><code>   if (oldTab != null) &#123;</code></pre></blockquote><blockquote><pre><code>       for (int j = 0; j &lt; oldCap; ++j) &#123;                               </code></pre></blockquote><blockquote><pre><code>           Node&lt;K,V&gt; e;</code></pre></blockquote><blockquote><pre><code>           if ((e = oldTab[j]) != null) &#123;</code></pre></blockquote><blockquote><pre><code>               oldTab[j] = null;</code></pre></blockquote><blockquote><pre><code>                   if (e.next == null)                                     </code></pre></blockquote><blockquote><pre><code>                       newTab[e.hash &amp; (newCap - 1)] = e;</code></pre></blockquote><blockquote><pre><code>                   else if (e instanceof TreeNode)</code></pre></blockquote><blockquote><pre><code>                       ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</code></pre></blockquote><blockquote><pre><code>                   else &#123; // preserve order</code></pre></blockquote><blockquote><pre><code>                       //下个节点为null，者进行尾插法插入</code></pre></blockquote><blockquote><pre><code>                       Node&lt;K,V&gt; loHead = null, loTail = null;</code></pre></blockquote><blockquote><pre><code>                       Node&lt;K,V&gt; hiHead = null, hiTail = null;</code></pre></blockquote><blockquote><pre><code>                       Node&lt;K,V&gt; next;</code></pre></blockquote><blockquote><pre><code>               do &#123;</code></pre></blockquote><blockquote><pre><code>                   next = e.next;</code></pre></blockquote><blockquote><pre><code>                   if ((e.hash &amp; oldCap) == 0) &#123;                     </code></pre></blockquote><blockquote><pre><code>                       if (loTail == null)                           </code></pre></blockquote><blockquote><pre><code>                           loHead = e;</code></pre></blockquote><blockquote><pre><code>                       else</code></pre></blockquote><blockquote><pre><code>                           loTail.next = e;                         </code></pre></blockquote><blockquote><pre><code>                           loTail = e;                                   </code></pre></blockquote><blockquote><pre><code>                       &#125;</code></pre></blockquote><blockquote><pre><code>                   else &#123;</code></pre></blockquote><blockquote><pre><code>                       if (hiTail == null)</code></pre></blockquote><blockquote><pre><code>                           hiHead = e;</code></pre></blockquote><blockquote><pre><code>                       else</code></pre></blockquote><blockquote><pre><code>                           hiTail.next = e;</code></pre></blockquote><blockquote><pre><code>                           hiTail = e;</code></pre></blockquote><blockquote><pre><code>                       &#125;</code></pre></blockquote><blockquote><pre><code>               &#125; while ((e = next) != null);</code></pre></blockquote><blockquote><pre><code>                   if (loTail != null) &#123;                                 </code></pre></blockquote><blockquote><pre><code>                       loTail.next = null;</code></pre></blockquote><blockquote><pre><code>                       newTab[j] = loHead;</code></pre></blockquote><blockquote><pre><code>                   &#125;</code></pre></blockquote><blockquote><pre><code>                   if (hiTail != null) &#123;</code></pre></blockquote><blockquote><pre><code>                       hiTail.next = null;</code></pre></blockquote><blockquote><pre><code>                       newTab[j + oldCap] = hiHead;</code></pre></blockquote><blockquote><pre><code>                   &#125;</code></pre></blockquote><blockquote><pre><code>               &#125;</code></pre></blockquote><blockquote><pre><code>           &#125;</code></pre></blockquote><blockquote><pre><code>       &#125;</code></pre></blockquote><blockquote><pre><code>   &#125;</code></pre></blockquote><blockquote><pre><code>   return newTab;</code></pre></blockquote><blockquote><p>   }</p></blockquote><blockquote><p>—————————————————–结束—————————————————–</p></blockquote><blockquote><p>另外：在多线程环境下不管是hashmap1.7或之后都是不安全的的，官网也建议使用concurrentHashMap。</p></blockquote><h2 id="concurrentHashMap简单了解"><a href="#concurrentHashMap简单了解" class="headerlink" title="concurrentHashMap简单了解"></a>concurrentHashMap简单了解</h2><blockquote><p>jdk1.7下的concurrentHashMap：</p></blockquote><p><img src="/2021/05/18/HashMap/26075772-dca3ff78ca1531ce.png" alt="1.7下的concurrentHashMap"></p><blockquote><p>1.7版本的concurrentHashMap采用的是类似分段锁的方式，每一个segment里面单独存放entity节点，各个粒子相互不影响。</p></blockquote><blockquote><p>1.8版本的concurrentHashMap和hashMap基本一致，保证线程安全，放弃了之前的segment，引入了synchronized同步锁的方式。</p></blockquote>]]></content>
    
    
    <summary type="html">本章简要概括一下hashMap的底层实现原理。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>synchronized</title>
    <link href="http://example.com/2021/04/08/synchronized/"/>
    <id>http://example.com/2021/04/08/synchronized/</id>
    <published>2021-04-08T05:02:43.000Z</published>
    <updated>2021-04-08T05:14:22.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p><strong>synchronized</strong> 是常用的保证线程同步的方法，我们打算讲述底层原理之前先了解其使用原理，我们就以卖票为例：</p><hr><p>[TOC]</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><blockquote><p>我们先重写Runnable接口，看看在引入synchronized之前多线程执行方式。</p></blockquote><h3 id="重写Runnable接口"><a href="#重写Runnable接口" class="headerlink" title="重写Runnable接口"></a>重写Runnable接口</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class ShouPiao implements Runnable &#123;</span><br><span class="line">    private <span class="built_in">int</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="meta">    @Override</span></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        <span class="keyword">while</span> (true) &#123;</span><br><span class="line">               <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               count--;</span><br><span class="line">               System.out.println(<span class="string">&quot;剩余&quot;</span> + count + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runnable shouPiao = new ShouPiao();</span><br><span class="line">        new Thread(shouPiao).start();</span><br><span class="line">        new Thread(shouPiao).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统计结果"><a href="#统计结果" class="headerlink" title="统计结果"></a>统计结果</h3><table><thead><tr><th align="left">第几次售票</th><th align="right">剩余票数</th></tr></thead><tbody><tr><td align="left">第一次</td><td align="right">8</td></tr><tr><td align="left">第二次</td><td align="right">8</td></tr><tr><td align="left">第三次</td><td align="right">7</td></tr><tr><td align="left">第四次</td><td align="right">7</td></tr><tr><td align="left">第五次</td><td align="right">6</td></tr><tr><td align="left">第六次</td><td align="right">5</td></tr><tr><td align="left">第七次</td><td align="right">4</td></tr><tr><td align="left">第八次</td><td align="right">3</td></tr><tr><td align="left">第九次</td><td align="right">2</td></tr><tr><td align="left">第十次</td><td align="right">1</td></tr><tr><td align="left">第十一次</td><td align="right">0</td></tr><tr><td align="left">第十二次</td><td align="right">-1</td></tr></tbody></table><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><blockquote><p>这时，我们发现不仅出现了相同票数，还有负数生成，这个时候现场就不是安全的了，此时在业务模块中加入synchronized</p></blockquote><h3 id="重写Runnable接口，并加入synchronized"><a href="#重写Runnable接口，并加入synchronized" class="headerlink" title="重写Runnable接口，并加入synchronized"></a>重写Runnable接口，并加入synchronized</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ShouPiao implements Runnable &#123;</span><br><span class="line">    private <span class="built_in">int</span> count = <span class="number">10</span>;</span><br><span class="line">    Object o =new Object();</span><br><span class="line"><span class="meta">    @Override</span></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        <span class="keyword">while</span> (true) &#123;</span><br><span class="line">            synchronized (o)&#123;</span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">                System.out.println(<span class="string">&quot;剩余&quot;</span> + count + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="再次打印结果"><a href="#再次打印结果" class="headerlink" title="再次打印结果"></a>再次打印结果</h3><table><thead><tr><th align="left">第几次售票</th><th align="right">剩余票数</th></tr></thead><tbody><tr><td align="left">第一次</td><td align="right">9</td></tr><tr><td align="left">第二次</td><td align="right">8</td></tr><tr><td align="left">第三次</td><td align="right">7</td></tr><tr><td align="left">第四次</td><td align="right">6</td></tr><tr><td align="left">第五次</td><td align="right">5</td></tr><tr><td align="left">第六次</td><td align="right">4</td></tr><tr><td align="left">第七次</td><td align="right">3</td></tr><tr><td align="left">第八次</td><td align="right">2</td></tr><tr><td align="left">第九次</td><td align="right">1</td></tr><tr><td align="left">第十次</td><td align="right">0</td></tr></tbody></table><blockquote><p><strong>结论:</strong> 这时的结果就是我们想要的了，说明线程已经是安全的了</p></blockquote><p>[TOC]</p><h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><blockquote><p> 讲述底层之前，建议大家了解一下jvm，java类经过javac编译后形成.class文件，.class文件经过jvm虚拟机编译成字节在运行（这一点目前也不是太清楚，欢迎指正）</p></blockquote><h3 id="新建类"><a href="#新建类" class="headerlink" title="新建类"></a>新建类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;</span><br><span class="line">    public synchronized void test()&#123;</span><br><span class="line">        synchronized (this)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进过javac编译后"><a href="#进过javac编译后" class="headerlink" title="进过javac编译后"></a>进过javac编译后</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">  public Test1();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, <span class="built_in">locals</span>=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial <span class="comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">1</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  this   LTest1;</span><br><span class="line"></span><br><span class="line">  public synchronized void test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0021</span>) ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, <span class="built_in">locals</span>=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: monitorenter</span><br><span class="line">         <span class="number">4</span>: aload_1</span><br><span class="line">         <span class="number">5</span>: monitorexit</span><br><span class="line">         <span class="number">6</span>: goto          <span class="number">14</span></span><br><span class="line">         <span class="number">9</span>: astore_2</span><br><span class="line">        <span class="number">10</span>: aload_1</span><br><span class="line">        <span class="number">11</span>: monitorexit</span><br><span class="line">        <span class="number">12</span>: aload_2</span><br><span class="line">        <span class="number">13</span>: athrow</span><br><span class="line">        <span class="number">14</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">         <span class="keyword">from</span>    to  target <span class="built_in">type</span></span><br><span class="line">             <span class="number">4</span>     <span class="number">6</span>     <span class="number">9</span>   <span class="built_in">any</span></span><br><span class="line">             <span class="number">9</span>    <span class="number">12</span>     <span class="number">9</span>   <span class="built_in">any</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">5</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">6</span>: <span class="number">14</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">15</span>     <span class="number">0</span>  this   LTest1;</span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">        frame_type = <span class="number">255</span> /* full_frame */</span><br><span class="line">          offset_delta = <span class="number">9</span></span><br><span class="line">          locals = [ class Test1, class java/lang/Object ]</span><br><span class="line">          stack = [ <span class="class"><span class="keyword">class</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Throwable</span> ]</span></span><br><span class="line">        frame_type = 250 /* chop */</span><br><span class="line">          offset_delta = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>底层浅析:</strong> 经过编译之后，我们发现方法头上会出现ACC_SYNCHRONIZED同步方法标识，内部方法块会出现有monitorenter指令和monitorexit指令</p></blockquote><blockquote><p> 其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置，当执行monitorenter指令时，当前线程将试图获取 objectref(即对象锁) 所对应的 monitor 的持有权，当 objectref 的monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。其他线程不能在争夺资源，使其变为同步操作。</p></blockquote><hr>]]></content>
    
    
    <summary type="html">本章简要概括一下synchronized的使用场景，以及一点点的底层实现原理，第一次写博客希望能得到大家的支持。</summary>
    
    
    
    
  </entry>
  
</feed>
