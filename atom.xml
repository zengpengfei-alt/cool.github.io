<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cool</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-08T05:14:22.334Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>cool</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>synchronized</title>
    <link href="http://example.com/2021/04/08/synchronized/"/>
    <id>http://example.com/2021/04/08/synchronized/</id>
    <published>2021-04-08T05:02:43.000Z</published>
    <updated>2021-04-08T05:14:22.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p><strong>synchronized</strong> 是常用的保证线程同步的方法，我们打算讲述底层原理之前先了解其使用原理，我们就以卖票为例：</p><hr><p>[TOC]</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><blockquote><p>我们先重写Runnable接口，看看在引入synchronized之前多线程执行方式。</p></blockquote><h3 id="重写Runnable接口"><a href="#重写Runnable接口" class="headerlink" title="重写Runnable接口"></a>重写Runnable接口</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class ShouPiao implements Runnable &#123;</span><br><span class="line">    private <span class="built_in">int</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="meta">    @Override</span></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        <span class="keyword">while</span> (true) &#123;</span><br><span class="line">               <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               count--;</span><br><span class="line">               System.out.println(<span class="string">&quot;剩余&quot;</span> + count + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runnable shouPiao = new ShouPiao();</span><br><span class="line">        new Thread(shouPiao).start();</span><br><span class="line">        new Thread(shouPiao).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统计结果"><a href="#统计结果" class="headerlink" title="统计结果"></a>统计结果</h3><table><thead><tr><th align="left">第几次售票</th><th align="right">剩余票数</th></tr></thead><tbody><tr><td align="left">第一次</td><td align="right">8</td></tr><tr><td align="left">第二次</td><td align="right">8</td></tr><tr><td align="left">第三次</td><td align="right">7</td></tr><tr><td align="left">第四次</td><td align="right">7</td></tr><tr><td align="left">第五次</td><td align="right">6</td></tr><tr><td align="left">第六次</td><td align="right">5</td></tr><tr><td align="left">第七次</td><td align="right">4</td></tr><tr><td align="left">第八次</td><td align="right">3</td></tr><tr><td align="left">第九次</td><td align="right">2</td></tr><tr><td align="left">第十次</td><td align="right">1</td></tr><tr><td align="left">第十一次</td><td align="right">0</td></tr><tr><td align="left">第十二次</td><td align="right">-1</td></tr></tbody></table><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><blockquote><p>这时，我们发现不仅出现了相同票数，还有负数生成，这个时候现场就不是安全的了，此时在业务模块中加入synchronized</p></blockquote><h3 id="重写Runnable接口，并加入synchronized"><a href="#重写Runnable接口，并加入synchronized" class="headerlink" title="重写Runnable接口，并加入synchronized"></a>重写Runnable接口，并加入synchronized</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ShouPiao implements Runnable &#123;</span><br><span class="line">    private <span class="built_in">int</span> count = <span class="number">10</span>;</span><br><span class="line">    Object o =new Object();</span><br><span class="line"><span class="meta">    @Override</span></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        <span class="keyword">while</span> (true) &#123;</span><br><span class="line">            synchronized (o)&#123;</span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">                System.out.println(<span class="string">&quot;剩余&quot;</span> + count + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="再次打印结果"><a href="#再次打印结果" class="headerlink" title="再次打印结果"></a>再次打印结果</h3><table><thead><tr><th align="left">第几次售票</th><th align="right">剩余票数</th></tr></thead><tbody><tr><td align="left">第一次</td><td align="right">9</td></tr><tr><td align="left">第二次</td><td align="right">8</td></tr><tr><td align="left">第三次</td><td align="right">7</td></tr><tr><td align="left">第四次</td><td align="right">6</td></tr><tr><td align="left">第五次</td><td align="right">5</td></tr><tr><td align="left">第六次</td><td align="right">4</td></tr><tr><td align="left">第七次</td><td align="right">3</td></tr><tr><td align="left">第八次</td><td align="right">2</td></tr><tr><td align="left">第九次</td><td align="right">1</td></tr><tr><td align="left">第十次</td><td align="right">0</td></tr></tbody></table><blockquote><p><strong>结论:</strong> 这时的结果就是我们想要的了，说明线程已经是安全的了</p></blockquote><p>[TOC]</p><h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><blockquote><p> 讲述底层之前，建议大家了解一下jvm，java类经过javac编译后形成.class文件，.class文件经过jvm虚拟机编译成字节在运行（这一点目前也不是太清楚，欢迎指正）</p></blockquote><h3 id="新建类"><a href="#新建类" class="headerlink" title="新建类"></a>新建类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;</span><br><span class="line">    public synchronized void test()&#123;</span><br><span class="line">        synchronized (this)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进过javac编译后"><a href="#进过javac编译后" class="headerlink" title="进过javac编译后"></a>进过javac编译后</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">  public Test1();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, <span class="built_in">locals</span>=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial <span class="comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">1</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  this   LTest1;</span><br><span class="line"></span><br><span class="line">  public synchronized void test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0021</span>) ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, <span class="built_in">locals</span>=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: monitorenter</span><br><span class="line">         <span class="number">4</span>: aload_1</span><br><span class="line">         <span class="number">5</span>: monitorexit</span><br><span class="line">         <span class="number">6</span>: goto          <span class="number">14</span></span><br><span class="line">         <span class="number">9</span>: astore_2</span><br><span class="line">        <span class="number">10</span>: aload_1</span><br><span class="line">        <span class="number">11</span>: monitorexit</span><br><span class="line">        <span class="number">12</span>: aload_2</span><br><span class="line">        <span class="number">13</span>: athrow</span><br><span class="line">        <span class="number">14</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">         <span class="keyword">from</span>    to  target <span class="built_in">type</span></span><br><span class="line">             <span class="number">4</span>     <span class="number">6</span>     <span class="number">9</span>   <span class="built_in">any</span></span><br><span class="line">             <span class="number">9</span>    <span class="number">12</span>     <span class="number">9</span>   <span class="built_in">any</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">5</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">6</span>: <span class="number">14</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">15</span>     <span class="number">0</span>  this   LTest1;</span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">        frame_type = <span class="number">255</span> /* full_frame */</span><br><span class="line">          offset_delta = <span class="number">9</span></span><br><span class="line">          locals = [ class Test1, class java/lang/Object ]</span><br><span class="line">          stack = [ <span class="class"><span class="keyword">class</span> <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Throwable</span> ]</span></span><br><span class="line">        frame_type = 250 /* chop */</span><br><span class="line">          offset_delta = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>底层浅析:</strong> 经过编译之后，我们发现方法头上会出现ACC_SYNCHRONIZED同步方法标识，内部方法块会出现有monitorenter指令和monitorexit指令</p></blockquote><blockquote><p> 其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置，当执行monitorenter指令时，当前线程将试图获取 objectref(即对象锁) 所对应的 monitor 的持有权，当 objectref 的monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。其他线程不能在争夺资源，使其变为同步操作。</p></blockquote><hr>]]></content>
    
    
    <summary type="html">本章简要概括一下synchronized的使用场景，以及一点点的底层实现原理，第一次写博客希望能得到大家的支持。</summary>
    
    
    
    
  </entry>
  
</feed>
